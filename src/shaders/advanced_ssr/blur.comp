#version 460 core

#include <gbuffer_encode.glsl>

layout (set = 0, binding = 0) uniform sampler2D DEPTH_TEX;
layout (set = 0, binding = 1) uniform sampler2D NORMAL_TEX;
layout (set = 0, binding = 2) uniform sampler2D REFLECTIONS_TEX;
layout (set = 0, binding = 3) uniform sampler2D MATERIAL_TEX;
layout (set = 0, binding = 4, rgba8) uniform image2D BLURED_REFLECTION;

const float PI = 3.1415926535897932384626433832795;

layout (push_constant) uniform PushConstants {
  float max_roughness;
  uint accumulate;
  uint disable_blur;
};

layout (local_size_x = 8, local_size_y = 8) in;
void main() {
  ivec2 tex_size = imageSize(BLURED_REFLECTION);
  ivec2 pixel_pos = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);
  vec2 screen_uv = vec2(pixel_pos)/vec2(tex_size);

  if (pixel_pos.x >= tex_size.x || pixel_pos.y >= tex_size.y) {
    return;
  }
  float roughness = texture(MATERIAL_TEX, screen_uv).g;
  roughness = mix(0.0, max_roughness, roughness);

  float center_depth = texelFetch(DEPTH_TEX, pixel_pos, 1).x; 
  vec3 center_normal = sample_gbuffer_normal(NORMAL_TEX, screen_uv);

  float sigma = mix(0.4, 4, roughness);
  if (disable_blur != 0) {
    sigma = 0.35;
  }

  float weight_sum = 0.f;
  vec3 color = vec3(0, 0, 0);

  int r = int(floor(3 * sigma - 0.01));
  float g = 1.0/(2 * PI * sigma * sigma);
  float e = 2 * sigma * sigma;

  for (int i = -r; i <= r; i++) {
    for (int j = -r; j <= r; j++) {
      ivec2 pos = pixel_pos + ivec2(i, j);
      vec2 uv = vec2(pos)/vec2(tex_size);

      float pixel_depth = texelFetch(DEPTH_TEX, pos, 1).x; 
      vec3 pixel_normal = sample_gbuffer_normal(NORMAL_TEX, uv);

      float bilateral_weight = max(1 - 1000 * abs(center_depth - pixel_depth)/center_depth, 0);
      float normal_weight = max(dot(center_normal, pixel_normal), 0);

      float w = g * exp(-(i*i + j*j)/e);
      w *= bilateral_weight;
      w *= normal_weight;

      color += texelFetch(REFLECTIONS_TEX, pixel_pos + ivec2(i, j), 0).rgb * w;
      weight_sum += w;
    }
  }

  color /= max(weight_sum, 0.001);

  if (accumulate != 0) {
    vec3 previous = imageLoad(BLURED_REFLECTION, pixel_pos).xyz;
    color = mix(previous, color, 0.1);
  }

  imageStore(BLURED_REFLECTION, pixel_pos, vec4(color, 0));
}

