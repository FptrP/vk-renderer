#version 460
#include <gbuffer_encode.glsl>
#include <screen_trace.glsl>

const int TILE_SIZE = 8;
const int THREAD_COUNT = TILE_SIZE * TILE_SIZE; 

layout (set = 0, binding = 0) uniform sampler2D DEPTH_TEX;
layout (set = 0, binding = 1) uniform sampler2D NORMAL_TEX;
layout (set = 0, binding = 2) uniform sampler2D COLOR_TEX;
layout (set = 0, binding = 3) uniform sampler2D MATERIAL_TEX;
layout (set = 0, binding = 4, rgba16f) uniform image2D OUTPUT_TEX;  

layout (set = 0, binding = 5) uniform Params {
  mat4 camera_normal;
  uint random;
  float angle_offset;
  float fovy;
  float aspect;
  float znear;
  float zfar;
};

vec4 gtao_camera_space(in ivec2 pos, in vec2 screen_uv, uint dirs_count);

layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
void main() {
  ivec2 tex_size = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
  ivec2 pixel_pos = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);
  vec2 screen_uv = vec2(pixel_pos)/vec2(tex_size);

  vec4 result = gtao_camera_space(pixel_pos, screen_uv, 1);
  imageStore(OUTPUT_TEX, pixel_pos, result);
}
const float PI = 3.1415926535897932384626433832795;
const float MAX_THIKNESS = 0.1;
const int SAMPLES = 20;

void integrate_direction(in vec2 start, in vec3 camera_start, in vec2 dir, int samples_count, in vec3 v, in vec3 normal, inout float h_cos, inout vec3 radiance) {
  h_cos = -1.0;
  radiance = vec3(0);
  int radiance_samples = 0;

  float previous_z = camera_start.z;

  for (int i = 1; i <= samples_count; i++) {
    vec2 tc = start + (float(i)/samples_count) * dir;
    float sample_depth = textureLod(DEPTH_TEX, tc, 0).r;

    vec3 sample_pos = reconstruct_view_vec(tc, sample_depth, fovy, aspect, znear, zfar);
    
    if (sample_pos.z > previous_z + MAX_THIKNESS) {
      break;
    }

    previous_z = sample_pos.z;
    vec3 sample_offset = normalize(sample_pos - camera_start);

    float sample_cos = dot(v, sample_offset);
    if (sample_cos >= h_cos) { //visible pixel
      h_cos = sample_cos;
      radiance_samples += 1;
      radiance += textureLod(COLOR_TEX, tc, 0).rgb * max(dot(normal, sample_offset), 0);
    }
  }

  radiance = (radiance_samples > 0)? (radiance/samples_count) : vec3(0);
}

float gtao_direction(in ivec2 pos) { // -> full rotation every 4 pixels
  return (1.0 / 16.0) * ((((pos.x + pos.y) & 3) << 2) + (pos.x & 3));
}

vec4 gtao_camera_space(in ivec2 pos, in vec2 screen_uv, uint dirs_count) {
  float frag_depth = textureLod(DEPTH_TEX, screen_uv, 0).r;
  if (frag_depth >= 1.f) {
    return vec4(0, 0, 0, 1);
  }

  vec3 camera_pos = reconstruct_view_vec(screen_uv, frag_depth, fovy, aspect, znear, zfar);
  vec3 w0 = -normalize(camera_pos);
  vec3 camera_normal = normalize((camera_normal * vec4(decode_normal(texture(NORMAL_TEX, screen_uv).xy), 0)).xyz);

  vec2 dir_radius = min(200.0/length(camera_pos), 32.0) / vec2(textureSize(DEPTH_TEX, 0));
  float base_angle = gtao_direction(pos) + angle_offset; 
  float sum = 0.f;
  vec3 radiance_sum = vec3(0);

  for (int dir_index = 0; dir_index < dirs_count; dir_index++) {
    float angle = 2 * PI * (base_angle + float(dir_index)/float(dirs_count));

    vec2 sample_direction = dir_radius * vec2(cos(angle), sin(angle));
    vec3 sample_end_pos = reconstruct_view_vec(screen_uv + sample_direction, frag_depth, fovy, aspect, znear, zfar);

    vec3 slice_normal = normalize(cross(w0, -sample_end_pos));
    vec3 normal_projected = camera_normal - dot(camera_normal, slice_normal) * slice_normal;
    float n = PI/2.0 - acos(dot(normalize(normal_projected), normalize(sample_end_pos - camera_pos)));

    float h_cos;
    vec3 dir_radiance;
    integrate_direction(screen_uv, camera_pos, sample_direction, SAMPLES, w0, camera_normal, h_cos, dir_radiance);

    float h = acos(h_cos);
    h = min(n + min(h - n, PI/2.0), h);
    sum += length(normal_projected) * 0.25 * max(-cos(2 * h - n) + cos(n) + 2*h*sin(n), 0);
    radiance_sum += dir_radiance;
  }
  float norm_coef = 2.0/float(dirs_count);

  return vec4(radiance_sum/float(dirs_count), norm_coef * sum);
}